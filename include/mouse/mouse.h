/**
 * @file mouse.h
 * @author Vaishanth Ramraj (vrmrj@umd.edu)
 * @author Pranav Limbekar (pranav05@umd.edu)
 * @author Rohit Patil (rpatil10@umd.edu)
 * @brief The file contains the Mouse class
 * @version 0.1
 * @date 2021-10-24
 *
 * @copyright Copyright (c) 2021
 *
 */

 /*! \mainpage Maze search algorithm
  *
  * This project consists of searching a path in a maze
  * and then task a mouse (robot) to follow the path.
  * - \subpage searchingPathPage "Searching a path"
  *
  * - \subpage followingPathPage "Following a path"
  *
  */

  /*! \page searchingPathPage Searching a path
   *
   * The search algorithm used for searching a path in a maze relies on
   * the depth-first search (DFS) approach. This algorithm is implemented in rwa2::Mouse::search_maze()
   *
   */

   /*! \page followingPathPage Following a path
    *
    * To follow a path generated by DFS, methods from the class API (api/api.h) must be used to interact
    * with the micromouse simulator.
    * - Methods of the API class are documented <a href="https://github.com/mackorone/mms#summary">here</a>.
    */


#ifndef MICROMOUSE_H
#define MICROMOUSE_H

#include "../node/node.h"
#include "../util/util.h"
#include "../api/api.h"
#include <array>
#include <stack>
#include <vector>
namespace rwa2 {
    /**
     * @brief This class is used to compute a path and execute the path.
     *
     */
    class Mouse {
        public:

        /**
         * @brief Construct a new MicroMouse object
         *
         * The robot is always at (0,0) and facing NORTH when the simulator starts
         */
        Mouse() :m_x{ 0 }, m_y{ 0 }, m_direction{ direction::NORTH } {
            //initialize the maze by placing around the perimeter of the maze
            API::setColor(0,0,'G');
            for (int x = 0; x < m_maze_width; x += 1) {
                for (int y = 0; y < m_maze_height; y += 1) {
                    m_maze.at(x).at(y).set_wall(direction::NORTH, (y == m_maze_height - 1));
                    m_maze.at(x).at(y).set_wall(direction::EAST, (x == m_maze_width - 1));
                    m_maze.at(x).at(y).set_wall(direction::SOUTH, (y == 0));
                    m_maze.at(x).at(y).set_wall(direction::WEST, (x == 0));
                }
            }
            //Sets the cordinates for the DFS to navigate through
            for (int x = 0; x < m_maze_width; x += 1) {
                for (int y = 0; y < m_maze_height; y += 1) {
                    m_maze.at(x).at(y).set_cords(x,y);
                    
                }
            }
        }

        bool back_tracking{false};

        /**
         * @brief Gets x and y coordinates of the mouse 
         * 
         */
        int get_pos_x(){
            return m_x;
        }

        int get_pos_y(){
            return m_y;
        }

        /**
         * @brief Checks of the direction of the mouse and gives comand to either turn left or right according to which direction mouse is facing
         * 
         */

        void turn_left();

        void turn_right();

        /**
         * @brief Sets the north of mouse to global north by orienting it by comands wrt the direction
         * 
         */

        void orient_north();

        /**
         * @brief Function which moves the fouse forward considering the direction and incrimen or decrement x and y accordingly
         * 
         * @param direction 
         */

        void move_forward(int direction);

        /**
         * @brief This function discovers by walls by checking all directions and sets the wall in colour.
         * 
         */

        void reveal_walls();

        void display_walls();

        /**
         * @brief When final path is discovered the color of remaining nodes is cleared
         * 
         */

        void clear_all_node_color();

        /**
         * @brief Verifies if the next node is already visited by checking the x and y coordinates of the node in vector
         * 
         * @param x 
         * @param y 
         * @param visited 
         * @return true 
         * @return false 
         */

        bool already_visited(int x, int y ,std::vector<std::pair<int,int>> &visited);

        /**
         * @brief Search for the path and navigates the mouse to goal position.
         * 
         * @param goal 
         * @return true if current node is goal.
         * @return false if current node is not the goal.
         */

        bool search_maze(const std::pair<int,int> goal);     

        /**
         * @brief This function generates the path from start to goal.
         * 
         * @param n 
         * @param g 
         */

        void generate_path(std::pair<int,int> n,std::pair<int,int> g);

        /**
         * @brief Backtracks the path if mouse hits a deadend.
         * 
         */

        void backtrack_path();

        /**
         * @brief Displays the temperory path based on th ecurrent node and changed it as moves forward.
         * 
         */

        void display_nav_path();

        /**
         * @brief Displays final path of the mouse from start to goal.
         * 
         */

        void display_final_path(); 

        /**
         * @brief check if the node is visited already by temporary navigation path.
         * 
         * @param x 
         * @param y 
         * @param visited 
         * @return true if already visited.
         * @return false if not visited.
         */

        bool check_visted_for_generated(int x, int y, std::vector<std::pair<int,int>> &visited);

        /**
         * @brief The stored nodes in stack while navigating are cleared.
         * 
         * @param stk 
         */

        void clear_stack(std::stack<std::pair<int,int>> stk);

        private:

        static const int m_maze_width{ 16 }; //width of the maze
        static const int m_maze_height{ 16 };//height of the maze
        int m_x; //x position of the robot in the maze
        int m_y; //y position of the robot in the maze
        int m_direction; //direction of the robot in the maze

        std::array<std::array<Node, m_maze_width>, m_maze_height> m_maze; //2D array maze object
        std::vector<std::pair<int,int>> mouse_node_hist; //vector pointing to pair of integers that cointain visited cordinates
        std::stack<std::pair<int,int>> mouse_route; //Stack containg the path traversed

        std::stack<std::pair<int,int>> nav_stack;
        std::vector<std::pair<int,int>> nav_visited;
    };
}
#endif